{"ast":null,"code":"import { Link, Node, NodeType, RelationState } from '../d3/models';\nimport { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let DataGraphService = /*#__PURE__*/(() => {\n  class DataGraphService {\n    constructor() {\n      this.nodes = [];\n      this.links = [];\n      this.idCounter = 1;\n      this.refreshGraph$ = new Subject();\n    }\n\n    nextNodeId() {\n      return this.idCounter;\n    }\n\n    addNode(name, type, label) {\n      let nuNode = new Node(this.idCounter, type, name, label);\n      this.nodes.push(nuNode);\n      this.idCounter++;\n      return nuNode;\n    }\n\n    findNode(name) {\n      return this.nodes.find(n => n.name == name);\n    }\n\n    findLink(name) {\n      return this.links.find(l => l.name == name);\n    }\n\n    addLink(source, target, name, label) {\n      let nuLink = new Link(source, target, name, label);\n      source.linkCount++;\n      target.linkCount++;\n      this.links.push(nuLink);\n      return nuLink;\n    }\n\n    copyLinkWithMainConcept(target, refNode) {\n      let mainNode = this.nodes.find(n => n.type == NodeType.ConceptoPrincipal);\n      let link = this.links.find(l => l.target.id == refNode.id);\n      return this.addLink(mainNode, target, link.name, link.label);\n    }\n\n    canRefreshGraph() {\n      this.refreshGraph$.next(true);\n    }\n\n    getRefreshGraph$() {\n      return this.refreshGraph$.asObservable();\n    }\n\n    anyData() {\n      return this.nodes.length > 0;\n    }\n\n    hideNode(id) {\n      this.nodes.find(n => n.id == id).hidden = true;\n      ;\n    }\n\n    getLinkLabelRelatedWithNode(nodeId) {\n      return this.links.find(n => n.source.id == nodeId || n.target.id == nodeId).label;\n    }\n\n    getRelationNameWithMainConcept(node) {\n      let link = this.links.find(l => l.target.id == node.id && l.source.type == NodeType.ConceptoPrincipal);\n      return link.name;\n    }\n\n    setRelationNodesVisibility(hidden, nodeIdToExlude) {\n      let mainNode = this.nodes.find(n => n.type == NodeType.ConceptoPrincipal);\n      this.links.forEach(l => {\n        let node;\n\n        if (l.source.id == mainNode.id) {\n          node = l.target;\n        } else if (l.target.id == mainNode.id) {\n          node = l.source;\n        }\n\n        if (node && node.id != mainNode.id && node.type != NodeType.InstanceCount && (!nodeIdToExlude || nodeIdToExlude && nodeIdToExlude != node.id)) {\n          node.hidden = hidden;\n          this.links.forEach(ll => {\n            if (ll.source.id == node.id && ll.target.id != mainNode.id && node.type != NodeType.InstanceCount) {\n              ll.target.hidden = hidden;\n            }\n          });\n        }\n      });\n\n      if (hidden) {\n        mainNode.relationState = RelationState.Ocultas;\n      }\n    }\n\n    IsThereVisibleInstanceNodes() {\n      return this.nodes.some(n => n.type == NodeType.Instance && !n.hidden);\n    }\n\n  }\n\n  DataGraphService.ɵfac = function DataGraphService_Factory(t) {\n    return new (t || DataGraphService)();\n  };\n\n  DataGraphService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: DataGraphService,\n    factory: DataGraphService.ɵfac\n  });\n  return DataGraphService;\n})();","map":null,"metadata":{},"sourceType":"module"}